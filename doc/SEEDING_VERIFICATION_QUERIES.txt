================================================================================
SEEDING VERIFICATION QUERIES
================================================================================
File: SEEDING_VERIFICATION_QUERIES.txt
Purpose: SQL queries untuk mengecek hasil seeding per seeder (01-40)
Author: MBG Development Team
Last Updated: 2025-01-21

Panduan Penggunaan:
1. Copy query yang diinginkan ke Supabase SQL Editor atau psql
2. Run query untuk melihat hasil seeding
3. Bandingkan jumlah record dengan expected count di setiap seeder

================================================================================
CORE SEEDERS (01-24)
================================================================================

--------------------------------------------------------------------------------
SEEDER 01: USERS
--------------------------------------------------------------------------------
File: 01-seed-users.ts
Table: users
Expected: 100-200 users

-- Count total users
SELECT COUNT(*) as total_users FROM users;

-- Count by role
SELECT role, COUNT(*) as count
FROM users
GROUP BY role
ORDER BY count DESC;

-- Sample data (first 10 users)
SELECT id, username, role, email, created_at
FROM users
ORDER BY id
LIMIT 10;

-- Check specific roles
SELECT role, COUNT(*) as count
FROM users
WHERE role IN ('ADMIN', 'SCHOOL', 'CATERING', 'GOVERNMENT')
GROUP BY role;

--------------------------------------------------------------------------------
SEEDER 02: MENU ITEMS
--------------------------------------------------------------------------------
File: 02-seed-menu-items.ts
Table: menu_items
Expected: 50-100 menu items

-- Count total menu items
SELECT COUNT(*) as total_menu_items FROM menu_items;

-- Count by category
SELECT category, COUNT(*) as count
FROM menu_items
GROUP BY category
ORDER BY count DESC;

-- Sample data
SELECT id, name, category, price, calories, is_vegetarian
FROM menu_items
ORDER BY id
LIMIT 10;

-- Check nutritional info
SELECT
    category,
    AVG(calories) as avg_calories,
    AVG(protein_grams) as avg_protein,
    COUNT(*) as count
FROM menu_items
GROUP BY category;

--------------------------------------------------------------------------------
SEEDER 03: ALLOCATIONS
--------------------------------------------------------------------------------
File: 03-seed-allocations.ts
Table: allocations
Expected: 200-500 allocations

-- Count total allocations
SELECT COUNT(*) as total_allocations FROM allocations;

-- Count by status
SELECT status, COUNT(*) as count
FROM allocations
GROUP BY status
ORDER BY count DESC;

-- Sample data
SELECT id, school_id, catering_id, daily_portion_count, status, start_date, end_date
FROM allocations
ORDER BY id
LIMIT 10;

-- Check allocations with schools and caterings
SELECT
    s.name as school_name,
    c.name as catering_name,
    a.daily_portion_count,
    a.status
FROM allocations a
JOIN schools s ON a.school_id = s.id
JOIN caterings c ON a.catering_id = c.id
LIMIT 10;

--------------------------------------------------------------------------------
SEEDER 04: DELIVERIES
--------------------------------------------------------------------------------
File: 04-seed-deliveries.ts
Table: deliveries
Expected: 500-2000 deliveries

-- Count total deliveries
SELECT COUNT(*) as total_deliveries FROM deliveries;

-- Count by status
SELECT delivery_status, COUNT(*) as count
FROM deliveries
GROUP BY delivery_status
ORDER BY count DESC;

-- Sample data
SELECT id, school_id, catering_id, delivery_date, portion_count, delivery_status
FROM deliveries
ORDER BY delivery_date DESC
LIMIT 10;

-- Check delivery statistics
SELECT
    delivery_status,
    COUNT(*) as count,
    SUM(portion_count) as total_portions,
    AVG(portion_count) as avg_portions
FROM deliveries
GROUP BY delivery_status;

-- Recent deliveries (last 7 days)
SELECT
    d.delivery_date,
    s.name as school_name,
    c.name as catering_name,
    d.portion_count,
    d.delivery_status
FROM deliveries d
JOIN schools s ON d.school_id = s.id
JOIN caterings c ON d.catering_id = c.id
WHERE d.delivery_date >= CURRENT_DATE - INTERVAL '7 days'
ORDER BY d.delivery_date DESC;

--------------------------------------------------------------------------------
SEEDER 05: VERIFICATIONS
--------------------------------------------------------------------------------
File: 05-seed-verifications.ts
Table: verifications
Expected: 300-1000 verifications

-- Count total verifications
SELECT COUNT(*) as total_verifications FROM verifications;

-- Count by status
SELECT status, COUNT(*) as count
FROM verifications
GROUP BY status
ORDER BY count DESC;

-- Sample data
SELECT id, delivery_id, verified_by, status, portion_verified, verification_timestamp
FROM verifications
ORDER BY verification_timestamp DESC
LIMIT 10;

-- Verification rate per school
SELECT
    s.name as school_name,
    COUNT(v.id) as total_verifications,
    SUM(CASE WHEN v.status = 'verified' THEN 1 ELSE 0 END) as verified_count,
    ROUND(SUM(CASE WHEN v.status = 'verified' THEN 1 ELSE 0 END)::numeric / COUNT(v.id) * 100, 2) as verification_rate
FROM verifications v
JOIN deliveries d ON v.delivery_id = d.id
JOIN schools s ON d.school_id = s.id
GROUP BY s.name
LIMIT 10;

--------------------------------------------------------------------------------
SEEDER 06: PAYMENTS
--------------------------------------------------------------------------------
File: 06-seed-payments.ts
Table: payments
Expected: 200-800 payments

-- Count total payments
SELECT COUNT(*) as total_payments FROM payments;

-- Count by status
SELECT payment_status, COUNT(*) as count
FROM payments
GROUP BY payment_status
ORDER BY count DESC;

-- Sample data
SELECT id, delivery_id, amount, payment_status, payment_date, blockchain_tx_hash
FROM payments
ORDER BY payment_date DESC
LIMIT 10;

-- Payment summary
SELECT
    payment_status,
    COUNT(*) as count,
    SUM(amount) as total_amount,
    AVG(amount) as avg_amount,
    MIN(amount) as min_amount,
    MAX(amount) as max_amount
FROM payments
GROUP BY payment_status;

-- Payments with blockchain transactions
SELECT COUNT(*) as payments_with_blockchain
FROM payments
WHERE blockchain_tx_hash IS NOT NULL;

--------------------------------------------------------------------------------
SEEDER 07: ISSUES
--------------------------------------------------------------------------------
File: 07-seed-issues.ts
Table: issues
Expected: 50-200 issues

-- Count total issues
SELECT COUNT(*) as total_issues FROM issues;

-- Count by severity
SELECT severity, COUNT(*) as count
FROM issues
GROUP BY severity
ORDER BY
    CASE severity
        WHEN 'critical' THEN 1
        WHEN 'high' THEN 2
        WHEN 'medium' THEN 3
        WHEN 'low' THEN 4
    END;

-- Count by status
SELECT status, COUNT(*) as count
FROM issues
GROUP BY status
ORDER BY count DESC;

-- Sample data
SELECT id, delivery_id, issue_type, severity, status, reported_at
FROM issues
ORDER BY reported_at DESC
LIMIT 10;

-- Open critical issues
SELECT
    i.id,
    i.issue_type,
    i.severity,
    s.name as school_name,
    i.reported_at
FROM issues i
JOIN deliveries d ON i.delivery_id = d.id
JOIN schools s ON d.school_id = s.id
WHERE i.status = 'open' AND i.severity = 'critical'
ORDER BY i.reported_at DESC;

--------------------------------------------------------------------------------
SEEDER 08: ESCROW TRANSACTIONS
--------------------------------------------------------------------------------
File: 08-seed-escrow-transactions.ts
Table: escrow_transactions
Expected: 100-400 transactions

-- Count total escrow transactions
SELECT COUNT(*) as total_escrow_transactions FROM escrow_transactions;

-- Count by status
SELECT status, COUNT(*) as count
FROM escrow_transactions
GROUP BY status
ORDER BY count DESC;

-- Sample data
SELECT id, payment_id, escrow_contract_address, amount_wei, status, blockchain_tx_hash
FROM escrow_transactions
ORDER BY created_at DESC
LIMIT 10;

-- Escrow summary by status
SELECT
    status,
    COUNT(*) as count,
    SUM(amount_wei::numeric) / 1e18 as total_eth,
    AVG(amount_wei::numeric) / 1e18 as avg_eth
FROM escrow_transactions
GROUP BY status;

-- Escrow transactions with blockchain confirmations
SELECT COUNT(*) as confirmed_transactions
FROM escrow_transactions
WHERE blockchain_confirmed = true;

--------------------------------------------------------------------------------
SEEDER 09: PAYMENT EVENTS
--------------------------------------------------------------------------------
File: 09-seed-payment-events.ts
Table: payment_events
Expected: 500-2000 events

-- Count total payment events
SELECT COUNT(*) as total_payment_events FROM payment_events;

-- Count by event type
SELECT event_type, COUNT(*) as count
FROM payment_events
GROUP BY event_type
ORDER BY count DESC;

-- Sample data
SELECT id, payment_id, event_type, event_data, timestamp
FROM payment_events
ORDER BY timestamp DESC
LIMIT 10;

-- Events timeline (last 24 hours)
SELECT
    DATE_TRUNC('hour', timestamp) as hour,
    event_type,
    COUNT(*) as count
FROM payment_events
WHERE timestamp >= NOW() - INTERVAL '24 hours'
GROUP BY hour, event_type
ORDER BY hour DESC, count DESC;

--------------------------------------------------------------------------------
SEEDER 10: DELIVERY CONFIRMATIONS
--------------------------------------------------------------------------------
File: 10-seed-delivery-confirmations.ts
Table: delivery_confirmations
Expected: 400-1500 confirmations

-- Count total delivery confirmations
SELECT COUNT(*) as total_confirmations FROM delivery_confirmations;

-- Count by confirmation type
SELECT confirmation_type, COUNT(*) as count
FROM delivery_confirmations
GROUP BY confirmation_type
ORDER BY count DESC;

-- Sample data
SELECT id, delivery_id, confirmed_by, confirmation_type, confirmed_at
FROM delivery_confirmations
ORDER BY confirmed_at DESC
LIMIT 10;

-- Confirmations by school
SELECT
    s.name as school_name,
    COUNT(dc.id) as total_confirmations,
    COUNT(DISTINCT dc.confirmation_type) as confirmation_types
FROM delivery_confirmations dc
JOIN deliveries d ON dc.delivery_id = d.id
JOIN schools s ON d.school_id = s.id
GROUP BY s.name
ORDER BY total_confirmations DESC
LIMIT 10;

--------------------------------------------------------------------------------
SEEDER 11: PUBLIC PAYMENT FEED
--------------------------------------------------------------------------------
File: 11-seed-public-payment-feed.ts
Table: public_payment_feed
Expected: 200-800 entries

-- Count total public payment feed entries
SELECT COUNT(*) as total_feed_entries FROM public_payment_feed;

-- Sample data
SELECT id, payment_id, public_message, amount_idr, published_at
FROM public_payment_feed
ORDER BY published_at DESC
LIMIT 10;

-- Feed entries by date
SELECT
    DATE(published_at) as date,
    COUNT(*) as entries,
    SUM(amount_idr) as total_amount
FROM public_payment_feed
GROUP BY DATE(published_at)
ORDER BY date DESC
LIMIT 7;

--------------------------------------------------------------------------------
SEEDER 12: REFUNDS
--------------------------------------------------------------------------------
File: 12-seed-refunds.ts
Table: refunds
Expected: 20-100 refunds

-- Count total refunds
SELECT COUNT(*) as total_refunds FROM refunds;

-- Count by status
SELECT refund_status, COUNT(*) as count
FROM refunds
GROUP BY refund_status
ORDER BY count DESC;

-- Sample data
SELECT id, payment_id, reason, refund_amount, refund_status, requested_at
FROM refunds
ORDER BY requested_at DESC
LIMIT 10;

-- Refund summary
SELECT
    refund_status,
    COUNT(*) as count,
    SUM(refund_amount) as total_refund,
    AVG(refund_amount) as avg_refund
FROM refunds
GROUP BY refund_status;

--------------------------------------------------------------------------------
SEEDER 13: PAYMENT METHODS
--------------------------------------------------------------------------------
File: 13-seed-payment-methods.ts
Table: payment_methods
Expected: 50-150 payment methods

-- Count total payment methods
SELECT COUNT(*) as total_payment_methods FROM payment_methods;

-- Count by type
SELECT method_type, COUNT(*) as count
FROM payment_methods
GROUP BY method_type
ORDER BY count DESC;

-- Sample data
SELECT id, user_id, method_type, is_default, created_at
FROM payment_methods
ORDER BY created_at DESC
LIMIT 10;

-- Active vs inactive payment methods
SELECT
    is_active,
    method_type,
    COUNT(*) as count
FROM payment_methods
GROUP BY is_active, method_type
ORDER BY is_active DESC, count DESC;

--------------------------------------------------------------------------------
SEEDER 14: BLOCKCHAIN SYNC LOG
--------------------------------------------------------------------------------
File: 14-seed-blockchain-sync-log.ts
Table: blockchain_sync_log
Expected: 100-500 log entries

-- Count total sync logs
SELECT COUNT(*) as total_sync_logs FROM blockchain_sync_log;

-- Count by status
SELECT sync_status, COUNT(*) as count
FROM blockchain_sync_log
GROUP BY sync_status
ORDER BY count DESC;

-- Sample data
SELECT id, block_number, sync_status, transactions_synced, sync_started_at, sync_completed_at
FROM blockchain_sync_log
ORDER BY sync_started_at DESC
LIMIT 10;

-- Sync performance
SELECT
    sync_status,
    COUNT(*) as count,
    SUM(transactions_synced) as total_transactions,
    AVG(EXTRACT(EPOCH FROM (sync_completed_at - sync_started_at))) as avg_duration_seconds
FROM blockchain_sync_log
WHERE sync_completed_at IS NOT NULL
GROUP BY sync_status;

--------------------------------------------------------------------------------
SEEDER 15: POVERTY DATA CACHE
--------------------------------------------------------------------------------
File: 15-seed-poverty-data-cache.ts
Table: poverty_data_cache
Expected: 34 provinces (one per province)

-- Count total poverty data entries
SELECT COUNT(*) as total_poverty_data FROM poverty_data_cache;

-- Sample data
SELECT province_code, province_name, poverty_percentage, total_poor_people, cached_at
FROM poverty_data_cache
ORDER BY poverty_percentage DESC
LIMIT 10;

-- Provinces with highest poverty
SELECT
    province_name,
    poverty_percentage,
    total_poor_people,
    data_source
FROM poverty_data_cache
ORDER BY poverty_percentage DESC
LIMIT 5;

-- Check data freshness
SELECT
    COUNT(*) as total,
    COUNT(CASE WHEN cached_at >= NOW() - INTERVAL '30 days' THEN 1 END) as fresh_data,
    COUNT(CASE WHEN cached_at < NOW() - INTERVAL '30 days' THEN 1 END) as stale_data
FROM poverty_data_cache;

--------------------------------------------------------------------------------
SEEDER 16: AI FOOD ANALYSES
--------------------------------------------------------------------------------
File: 16-seed-ai-food-analyses.ts
Table: ai_food_analyses
Expected: 100-400 analyses

-- Count total AI analyses
SELECT COUNT(*) as total_analyses FROM ai_food_analyses;

-- Count by analysis type
SELECT analysis_type, COUNT(*) as count
FROM ai_food_analyses
GROUP BY analysis_type
ORDER BY count DESC;

-- Sample data
SELECT id, delivery_id, analysis_type, ai_score, analyzed_at
FROM ai_food_analyses
ORDER BY analyzed_at DESC
LIMIT 10;

-- Average AI scores by type
SELECT
    analysis_type,
    COUNT(*) as count,
    AVG(ai_score) as avg_score,
    MIN(ai_score) as min_score,
    MAX(ai_score) as max_score
FROM ai_food_analyses
GROUP BY analysis_type;

-- Low quality detections (score < 50)
SELECT COUNT(*) as low_quality_detections
FROM ai_food_analyses
WHERE ai_score < 50;

--------------------------------------------------------------------------------
SEEDER 17: ANOMALY ALERTS
--------------------------------------------------------------------------------
File: 17-seed-anomaly-alerts.ts
Table: anomaly_alerts
Expected: 30-150 alerts

-- Count total anomaly alerts
SELECT COUNT(*) as total_anomaly_alerts FROM anomaly_alerts;

-- Count by severity
SELECT severity, COUNT(*) as count
FROM anomaly_alerts
GROUP BY severity
ORDER BY
    CASE severity
        WHEN 'critical' THEN 1
        WHEN 'high' THEN 2
        WHEN 'medium' THEN 3
        WHEN 'low' THEN 4
    END;

-- Count by status
SELECT status, COUNT(*) as count
FROM anomaly_alerts
GROUP BY status
ORDER BY count DESC;

-- Sample data
SELECT id, anomaly_type, severity, status, detected_at
FROM anomaly_alerts
ORDER BY detected_at DESC
LIMIT 10;

-- Unresolved critical alerts
SELECT
    id,
    anomaly_type,
    severity,
    detected_at,
    EXTRACT(EPOCH FROM (NOW() - detected_at))/3600 as hours_open
FROM anomaly_alerts
WHERE status != 'resolved' AND severity = 'critical'
ORDER BY detected_at ASC;

--------------------------------------------------------------------------------
SEEDER 18: VENDOR RISK ASSESSMENTS
--------------------------------------------------------------------------------
File: 18-seed-vendor-risk-assessments.ts
Table: vendor_risk_assessments
Expected: 50-200 assessments

-- Count total risk assessments
SELECT COUNT(*) as total_assessments FROM vendor_risk_assessments;

-- Count by risk level
SELECT risk_level, COUNT(*) as count
FROM vendor_risk_assessments
GROUP BY risk_level
ORDER BY
    CASE risk_level
        WHEN 'high' THEN 1
        WHEN 'medium' THEN 2
        WHEN 'low' THEN 3
    END;

-- Sample data
SELECT id, catering_id, risk_level, risk_score, assessed_at
FROM vendor_risk_assessments
ORDER BY assessed_at DESC
LIMIT 10;

-- Risk assessment by catering
SELECT
    c.name as catering_name,
    vra.risk_level,
    vra.risk_score,
    vra.assessed_at
FROM vendor_risk_assessments vra
JOIN caterings c ON vra.catering_id = c.id
ORDER BY vra.risk_score DESC
LIMIT 10;

-- High risk vendors
SELECT COUNT(*) as high_risk_vendors
FROM vendor_risk_assessments
WHERE risk_level = 'high';

--------------------------------------------------------------------------------
SEEDER 19: STUNTING DATA CACHE
--------------------------------------------------------------------------------
File: 19-seed-stunting-data-cache.ts
Table: stunting_data_cache
Expected: 34 provinces (one per province)

-- Count total stunting data entries
SELECT COUNT(*) as total_stunting_data FROM stunting_data_cache;

-- Sample data
SELECT province_code, province_name, stunting_percentage, total_stunted_children, cached_at
FROM stunting_data_cache
ORDER BY stunting_percentage DESC
LIMIT 10;

-- Provinces with highest stunting
SELECT
    province_name,
    stunting_percentage,
    total_stunted_children,
    data_source
FROM stunting_data_cache
ORDER BY stunting_percentage DESC
LIMIT 5;

-- Check data freshness
SELECT
    COUNT(*) as total,
    COUNT(CASE WHEN cached_at >= NOW() - INTERVAL '30 days' THEN 1 END) as fresh_data,
    COUNT(CASE WHEN cached_at < NOW() - INTERVAL '30 days' THEN 1 END) as stale_data
FROM stunting_data_cache;

--------------------------------------------------------------------------------
SEEDER 20: BLOCKCHAIN TRANSACTION HISTORY
--------------------------------------------------------------------------------
File: 20-seed-blockchain-transaction-history.ts
Table: blockchain_transaction_history
Expected: 200-1000 transactions

-- Count total blockchain transactions
SELECT COUNT(*) as total_blockchain_transactions FROM blockchain_transaction_history;

-- Count by status
SELECT tx_status, COUNT(*) as count
FROM blockchain_transaction_history
GROUP BY tx_status
ORDER BY count DESC;

-- Sample data
SELECT id, tx_hash, from_address, to_address, value_wei, tx_status, block_number
FROM blockchain_transaction_history
ORDER BY timestamp DESC
LIMIT 10;

-- Transaction volume
SELECT
    tx_status,
    COUNT(*) as count,
    SUM(value_wei::numeric) / 1e18 as total_eth,
    AVG(gas_used) as avg_gas_used
FROM blockchain_transaction_history
GROUP BY tx_status;

-- Recent confirmed transactions
SELECT
    tx_hash,
    value_wei::numeric / 1e18 as eth_value,
    block_number,
    timestamp
FROM blockchain_transaction_history
WHERE tx_status = 'confirmed'
ORDER BY timestamp DESC
LIMIT 10;

--------------------------------------------------------------------------------
SEEDER 21: SMART CONTRACT EVENTS RAW
--------------------------------------------------------------------------------
File: 21-seed-smart-contract-events-raw.ts
Table: smart_contract_events_raw
Expected: 300-1500 events

-- Count total smart contract events
SELECT COUNT(*) as total_contract_events FROM smart_contract_events_raw;

-- Count by event name
SELECT event_name, COUNT(*) as count
FROM smart_contract_events_raw
GROUP BY event_name
ORDER BY count DESC;

-- Sample data
SELECT id, event_name, contract_address, block_number, transaction_hash, timestamp
FROM smart_contract_events_raw
ORDER BY timestamp DESC
LIMIT 10;

-- Events by contract
SELECT
    contract_address,
    COUNT(*) as total_events,
    COUNT(DISTINCT event_name) as unique_event_types
FROM smart_contract_events_raw
GROUP BY contract_address
ORDER BY total_events DESC;

-- Recent payment-related events
SELECT
    event_name,
    contract_address,
    block_number,
    timestamp
FROM smart_contract_events_raw
WHERE event_name IN ('PaymentEscrowed', 'PaymentReleased', 'PaymentRefunded')
ORDER BY timestamp DESC
LIMIT 20;

--------------------------------------------------------------------------------
SEEDER 22: WALLET BALANCES SNAPSHOT
--------------------------------------------------------------------------------
File: 22-seed-wallet-balances-snapshot.ts
Table: wallet_balances_snapshot
Expected: 100-400 snapshots

-- Count total wallet snapshots
SELECT COUNT(*) as total_snapshots FROM wallet_balances_snapshot;

-- Sample data
SELECT id, wallet_address, balance_wei, snapshot_date
FROM wallet_balances_snapshot
ORDER BY snapshot_date DESC
LIMIT 10;

-- Latest balances per wallet
SELECT
    wallet_address,
    balance_wei::numeric / 1e18 as balance_eth,
    snapshot_date
FROM wallet_balances_snapshot
WHERE (wallet_address, snapshot_date) IN (
    SELECT wallet_address, MAX(snapshot_date)
    FROM wallet_balances_snapshot
    GROUP BY wallet_address
)
ORDER BY balance_wei DESC
LIMIT 10;

-- Balance changes over time
SELECT
    DATE(snapshot_date) as date,
    COUNT(DISTINCT wallet_address) as unique_wallets,
    SUM(balance_wei::numeric) / 1e18 as total_eth
FROM wallet_balances_snapshot
GROUP BY DATE(snapshot_date)
ORDER BY date DESC
LIMIT 7;

--------------------------------------------------------------------------------
SEEDER 23: GEOCODE SCHOOLS
--------------------------------------------------------------------------------
File: 23-geocode-schools.ts
Table: schools (updates latitude, longitude)
Expected: Updates existing schools

-- Count schools with coordinates
SELECT COUNT(*) as schools_with_coordinates
FROM schools
WHERE latitude IS NOT NULL AND longitude IS NOT NULL;

-- Count schools without coordinates
SELECT COUNT(*) as schools_without_coordinates
FROM schools
WHERE latitude IS NULL OR longitude IS NULL;

-- Sample geocoded schools
SELECT id, name, address, latitude, longitude
FROM schools
WHERE latitude IS NOT NULL AND longitude IS NOT NULL
ORDER BY id
LIMIT 10;

-- Schools by province with coordinates
SELECT
    province,
    COUNT(*) as total_schools,
    SUM(CASE WHEN latitude IS NOT NULL THEN 1 ELSE 0 END) as geocoded,
    ROUND(SUM(CASE WHEN latitude IS NOT NULL THEN 1 ELSE 0 END)::numeric / COUNT(*) * 100, 2) as geocoding_percentage
FROM schools
GROUP BY province
ORDER BY geocoding_percentage DESC;

--------------------------------------------------------------------------------
SEEDER 24: CALCULATE PRIORITY SCORES
--------------------------------------------------------------------------------
File: 24-calculate-priority-scores.ts
Table: schools (updates priority_score)
Expected: Updates existing schools

-- Count schools with priority scores
SELECT COUNT(*) as schools_with_priority_score
FROM schools
WHERE priority_score IS NOT NULL;

-- Priority score distribution
SELECT
    CASE
        WHEN priority_score >= 80 THEN 'Very High (80-100)'
        WHEN priority_score >= 60 THEN 'High (60-79)'
        WHEN priority_score >= 40 THEN 'Medium (40-59)'
        WHEN priority_score >= 20 THEN 'Low (20-39)'
        ELSE 'Very Low (0-19)'
    END as priority_category,
    COUNT(*) as count
FROM schools
WHERE priority_score IS NOT NULL
GROUP BY priority_category
ORDER BY MIN(priority_score) DESC;

-- Top priority schools
SELECT id, name, province, city, priority_score
FROM schools
WHERE priority_score IS NOT NULL
ORDER BY priority_score DESC
LIMIT 10;

-- Bottom priority schools
SELECT id, name, province, city, priority_score
FROM schools
WHERE priority_score IS NOT NULL
ORDER BY priority_score ASC
LIMIT 10;

-- Average priority score by province
SELECT
    province,
    COUNT(*) as total_schools,
    AVG(priority_score) as avg_priority_score,
    MIN(priority_score) as min_score,
    MAX(priority_score) as max_score
FROM schools
WHERE priority_score IS NOT NULL
GROUP BY province
ORDER BY avg_priority_score DESC
LIMIT 10;


================================================================================
NICE-TO-HAVE SEEDERS (25-40)
================================================================================

--------------------------------------------------------------------------------
SEEDER 25: HISTORICAL DELIVERIES
--------------------------------------------------------------------------------
File: 25-seed-historical-deliveries.ts
Table: deliveries (historical data)
Expected: 1000-5000 historical deliveries

-- Count historical deliveries (older than 30 days)
SELECT COUNT(*) as historical_deliveries
FROM deliveries
WHERE delivery_date < CURRENT_DATE - INTERVAL '30 days';

-- Historical deliveries by month
SELECT
    TO_CHAR(delivery_date, 'YYYY-MM') as month,
    COUNT(*) as deliveries,
    SUM(portion_count) as total_portions
FROM deliveries
WHERE delivery_date < CURRENT_DATE - INTERVAL '30 days'
GROUP BY month
ORDER BY month DESC;

-- Delivery trend (last 6 months)
SELECT
    DATE_TRUNC('month', delivery_date) as month,
    COUNT(*) as deliveries,
    SUM(portion_count) as portions,
    COUNT(DISTINCT school_id) as unique_schools
FROM deliveries
WHERE delivery_date >= CURRENT_DATE - INTERVAL '6 months'
GROUP BY month
ORDER BY month DESC;

--------------------------------------------------------------------------------
SEEDER 26: HISTORICAL PAYMENTS
--------------------------------------------------------------------------------
File: 26-seed-historical-payments.ts
Table: payments (historical data)
Expected: 800-3000 historical payments

-- Count historical payments (older than 30 days)
SELECT COUNT(*) as historical_payments
FROM payments
WHERE payment_date < CURRENT_DATE - INTERVAL '30 days';

-- Historical payments by month
SELECT
    TO_CHAR(payment_date, 'YYYY-MM') as month,
    COUNT(*) as payments,
    SUM(amount) as total_amount
FROM payments
WHERE payment_date < CURRENT_DATE - INTERVAL '30 days'
GROUP BY month
ORDER BY month DESC;

-- Payment trend (last 6 months)
SELECT
    DATE_TRUNC('month', payment_date) as month,
    COUNT(*) as payments,
    SUM(amount) as total_amount,
    AVG(amount) as avg_amount
FROM payments
WHERE payment_date >= CURRENT_DATE - INTERVAL '6 months'
GROUP BY month
ORDER BY month DESC;

--------------------------------------------------------------------------------
SEEDER 27: USER ACTIVITY LOGS
--------------------------------------------------------------------------------
File: 27-seed-user-activity-logs.ts
Table: user_activity_logs
Expected: 2000-10000 activity logs

-- Count total activity logs
SELECT COUNT(*) as total_activity_logs FROM user_activity_logs;

-- Count by action type
SELECT action_type, COUNT(*) as count
FROM user_activity_logs
GROUP BY action_type
ORDER BY count DESC;

-- Sample data
SELECT id, user_id, action_type, ip_address, user_agent, created_at
FROM user_activity_logs
ORDER BY created_at DESC
LIMIT 10;

-- Activity by user role
SELECT
    u.role,
    COUNT(ual.id) as total_activities,
    COUNT(DISTINCT ual.user_id) as active_users
FROM user_activity_logs ual
JOIN users u ON ual.user_id = u.id
GROUP BY u.role
ORDER BY total_activities DESC;

-- Recent activities (last 24 hours)
SELECT
    u.username,
    ual.action_type,
    ual.created_at
FROM user_activity_logs ual
JOIN users u ON ual.user_id = u.id
WHERE ual.created_at >= NOW() - INTERVAL '24 hours'
ORDER BY ual.created_at DESC
LIMIT 20;

-- Most active users
SELECT
    u.username,
    u.role,
    COUNT(ual.id) as activity_count
FROM user_activity_logs ual
JOIN users u ON ual.user_id = u.id
GROUP BY u.username, u.role
ORDER BY activity_count DESC
LIMIT 10;

--------------------------------------------------------------------------------
SEEDER 28: NOTIFICATION HISTORY
--------------------------------------------------------------------------------
File: 28-seed-notification-history.ts
Table: notification_history
Expected: 1000-5000 notifications

-- Count total notifications
SELECT COUNT(*) as total_notifications FROM notification_history;

-- Count by notification type
SELECT notification_type, COUNT(*) as count
FROM notification_history
GROUP BY notification_type
ORDER BY count DESC;

-- Count by status
SELECT status, COUNT(*) as count
FROM notification_history
GROUP BY status
ORDER BY count DESC;

-- Sample data
SELECT id, user_id, notification_type, title, status, sent_at
FROM notification_history
ORDER BY sent_at DESC
LIMIT 10;

-- Notification delivery rate
SELECT
    notification_type,
    COUNT(*) as total,
    SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
    ROUND(SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END)::numeric / COUNT(*) * 100, 2) as delivery_rate
FROM notification_history
GROUP BY notification_type
ORDER BY total DESC;

-- Unread notifications per user
SELECT
    u.username,
    COUNT(nh.id) as unread_count
FROM notification_history nh
JOIN users u ON nh.user_id = u.id
WHERE nh.read_at IS NULL
GROUP BY u.username
ORDER BY unread_count DESC
LIMIT 10;

--------------------------------------------------------------------------------
SEEDER 29: SYSTEM CONFIG
--------------------------------------------------------------------------------
File: 29-seed-system-config.ts
Table: system_config
Expected: 20-40 config entries

-- Count total system configs
SELECT COUNT(*) as total_configs FROM system_config;

-- Count by category
SELECT category, COUNT(*) as count
FROM system_config
GROUP BY category
ORDER BY count DESC;

-- Sample data
SELECT id, key, description, category, is_public, updated_at
FROM system_config
ORDER BY category, key
LIMIT 10;

-- Public configs (accessible to frontend)
SELECT key, value, description
FROM system_config
WHERE is_public = true
ORDER BY category, key;

-- AI-related configs
SELECT key, value, description
FROM system_config
WHERE category = 'ai'
ORDER BY key;

-- Blockchain configs
SELECT key, value, description
FROM system_config
WHERE category = 'blockchain'
ORDER BY key;

--------------------------------------------------------------------------------
SEEDER 30: WEEKLY MENU PLANS
--------------------------------------------------------------------------------
File: 30-seed-weekly-menu-plans.ts
Table: weekly_menu_plans
Expected: 100-500 menu plans

-- Count total menu plans
SELECT COUNT(*) as total_menu_plans FROM weekly_menu_plans;

-- Count by status
SELECT status, COUNT(*) as count
FROM weekly_menu_plans
GROUP BY status
ORDER BY count DESC;

-- Sample data
SELECT id, school_id, catering_id, week_start_date, status, total_cost
FROM weekly_menu_plans
ORDER BY week_start_date DESC
LIMIT 10;

-- Active menu plans
SELECT
    s.name as school_name,
    c.name as catering_name,
    wmp.week_start_date,
    wmp.total_cost,
    wmp.total_portions
FROM weekly_menu_plans wmp
JOIN schools s ON wmp.school_id = s.id
JOIN caterings c ON wmp.catering_id = c.id
WHERE wmp.status = 'active'
ORDER BY wmp.week_start_date DESC;

-- Menu plans by catering
SELECT
    c.name as catering_name,
    COUNT(wmp.id) as total_plans,
    SUM(wmp.total_portions) as total_portions,
    SUM(wmp.total_cost) as total_revenue
FROM weekly_menu_plans wmp
JOIN caterings c ON wmp.catering_id = c.id
GROUP BY c.name
ORDER BY total_revenue DESC;

--------------------------------------------------------------------------------
SEEDER 31: PERFORMANCE METRICS
--------------------------------------------------------------------------------
File: 31-seed-performance-metrics.ts
Table: performance_metrics
Expected: 200-1000 metric entries

-- Count total performance metrics
SELECT COUNT(*) as total_metrics FROM performance_metrics;

-- Count by metric type
SELECT metric_type, COUNT(*) as count
FROM performance_metrics
GROUP BY metric_type
ORDER BY count DESC;

-- Sample data
SELECT id, entity_type, entity_id, metric_type, metric_value, recorded_at
FROM performance_metrics
ORDER BY recorded_at DESC
LIMIT 10;

-- Average metrics by type
SELECT
    metric_type,
    COUNT(*) as count,
    AVG(metric_value) as avg_value,
    MIN(metric_value) as min_value,
    MAX(metric_value) as max_value
FROM performance_metrics
GROUP BY metric_type
ORDER BY metric_type;

-- School performance (delivery success rate)
SELECT
    s.name as school_name,
    AVG(pm.metric_value) as avg_delivery_success_rate
FROM performance_metrics pm
JOIN schools s ON pm.entity_id = s.id
WHERE pm.entity_type = 'school' AND pm.metric_type = 'delivery_success_rate'
GROUP BY s.name
ORDER BY avg_delivery_success_rate DESC
LIMIT 10;

-- Catering performance (on-time delivery rate)
SELECT
    c.name as catering_name,
    AVG(pm.metric_value) as avg_on_time_rate
FROM performance_metrics pm
JOIN caterings c ON pm.entity_id = c.id
WHERE pm.entity_type = 'catering' AND pm.metric_type = 'on_time_delivery_rate'
GROUP BY c.name
ORDER BY avg_on_time_rate DESC
LIMIT 10;

--------------------------------------------------------------------------------
SEEDER 32: REGIONAL STATISTICS
--------------------------------------------------------------------------------
File: 32-seed-regional-statistics.ts
Table: regional_statistics
Expected: 200-500 regional stats

-- Count total regional statistics
SELECT COUNT(*) as total_regional_stats FROM regional_statistics;

-- Count by region type
SELECT region_type, COUNT(*) as count
FROM regional_statistics
GROUP BY region_type
ORDER BY count DESC;

-- Sample data
SELECT id, region_type, region_name, total_schools, total_students, total_deliveries, recorded_date
FROM regional_statistics
ORDER BY recorded_date DESC
LIMIT 10;

-- Latest stats by province
SELECT
    region_name,
    total_schools,
    total_students,
    total_deliveries,
    total_portions,
    recorded_date
FROM regional_statistics
WHERE region_type = 'province' AND recorded_date >= CURRENT_DATE - INTERVAL '7 days'
ORDER BY total_students DESC;

-- Top provinces by delivery coverage
SELECT
    region_name,
    total_schools,
    total_deliveries,
    ROUND((total_deliveries::numeric / total_schools), 2) as deliveries_per_school
FROM regional_statistics
WHERE region_type = 'province'
ORDER BY deliveries_per_school DESC
LIMIT 10;

-- Regional budget utilization
SELECT
    region_name,
    budget_allocated,
    budget_spent,
    ROUND((budget_spent::numeric / NULLIF(budget_allocated, 0) * 100), 2) as utilization_percentage
FROM regional_statistics
WHERE region_type = 'province' AND budget_allocated > 0
ORDER BY utilization_percentage DESC;

--------------------------------------------------------------------------------
SEEDER 33: CATERING CONTRACTS
--------------------------------------------------------------------------------
File: 33-seed-catering-contracts.ts
Table: catering_contracts
Expected: 50-200 contracts

-- Count total contracts
SELECT COUNT(*) as total_contracts FROM catering_contracts;

-- Count by status
SELECT contract_status, COUNT(*) as count
FROM catering_contracts
GROUP BY contract_status
ORDER BY count DESC;

-- Sample data
SELECT id, catering_id, contract_number, start_date, end_date, contract_value, contract_status
FROM catering_contracts
ORDER BY start_date DESC
LIMIT 10;

-- Active contracts
SELECT
    c.name as catering_name,
    cc.contract_number,
    cc.start_date,
    cc.end_date,
    cc.contract_value,
    cc.daily_capacity
FROM catering_contracts cc
JOIN caterings c ON cc.catering_id = c.id
WHERE cc.contract_status = 'active'
ORDER BY cc.contract_value DESC;

-- Contract value by catering
SELECT
    c.name as catering_name,
    COUNT(cc.id) as total_contracts,
    SUM(cc.contract_value) as total_value,
    AVG(cc.daily_capacity) as avg_daily_capacity
FROM catering_contracts cc
JOIN caterings c ON cc.catering_id = c.id
GROUP BY c.name
ORDER BY total_value DESC;

-- Expiring contracts (next 30 days)
SELECT
    c.name as catering_name,
    cc.contract_number,
    cc.end_date,
    CURRENT_DATE - cc.end_date as days_until_expiry
FROM catering_contracts cc
JOIN caterings c ON cc.catering_id = c.id
WHERE cc.end_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '30 days'
  AND cc.contract_status = 'active'
ORDER BY cc.end_date ASC;

--------------------------------------------------------------------------------
SEEDER 34: PHOTO EVIDENCE
--------------------------------------------------------------------------------
File: 34-seed-photo-evidence.ts
Table: photo_evidence
Expected: 500-3000 photos

-- Count total photos
SELECT COUNT(*) as total_photos FROM photo_evidence;

-- Count by photo type
SELECT photo_type, COUNT(*) as count
FROM photo_evidence
GROUP BY photo_type
ORDER BY count DESC;

-- Sample data
SELECT id, delivery_id, photo_type, uploaded_by, uploaded_at
FROM photo_evidence
ORDER BY uploaded_at DESC
LIMIT 10;

-- Photos by verification status
SELECT
    is_verified,
    COUNT(*) as count
FROM photo_evidence
GROUP BY is_verified;

-- Recent uploads (last 7 days)
SELECT
    DATE(uploaded_at) as date,
    photo_type,
    COUNT(*) as uploads
FROM photo_evidence
WHERE uploaded_at >= CURRENT_DATE - INTERVAL '7 days'
GROUP BY DATE(uploaded_at), photo_type
ORDER BY date DESC, uploads DESC;

-- AI analysis status
SELECT
    CASE
        WHEN ai_analysis_result IS NOT NULL THEN 'Analyzed'
        ELSE 'Not Analyzed'
    END as analysis_status,
    COUNT(*) as count
FROM photo_evidence
GROUP BY analysis_status;

--------------------------------------------------------------------------------
SEEDER 35: PUBLIC FEEDBACK
--------------------------------------------------------------------------------
File: 35-seed-public-feedback.ts
Table: public_feedback
Expected: 200-1000 feedback entries

-- Count total feedback
SELECT COUNT(*) as total_feedback FROM public_feedback;

-- Count by feedback type
SELECT feedback_type, COUNT(*) as count
FROM public_feedback
GROUP BY feedback_type
ORDER BY count DESC;

-- Count by rating
SELECT rating, COUNT(*) as count
FROM public_feedback
GROUP BY rating
ORDER BY rating DESC;

-- Sample data
SELECT id, school_id, feedback_type, rating, status, submitted_at
FROM public_feedback
ORDER BY submitted_at DESC
LIMIT 10;

-- Average rating by school
SELECT
    s.name as school_name,
    COUNT(pf.id) as total_feedback,
    AVG(pf.rating) as avg_rating
FROM public_feedback pf
JOIN schools s ON pf.school_id = s.id
WHERE pf.rating IS NOT NULL
GROUP BY s.name
ORDER BY avg_rating DESC
LIMIT 10;

-- Feedback sentiment distribution
SELECT
    feedback_type,
    CASE
        WHEN rating >= 4 THEN 'Positive'
        WHEN rating = 3 THEN 'Neutral'
        ELSE 'Negative'
    END as sentiment,
    COUNT(*) as count
FROM public_feedback
WHERE rating IS NOT NULL
GROUP BY feedback_type, sentiment
ORDER BY feedback_type, sentiment;

-- Unresolved complaints
SELECT
    s.name as school_name,
    pf.comment,
    pf.rating,
    pf.submitted_at
FROM public_feedback pf
JOIN schools s ON pf.school_id = s.id
WHERE pf.feedback_type = 'complaint' AND pf.status != 'resolved'
ORDER BY pf.submitted_at DESC;

--------------------------------------------------------------------------------
SEEDER 36: BUDGET ALLOCATIONS
--------------------------------------------------------------------------------
File: 36-seed-budget-allocations.ts
Table: budget_allocations
Expected: 100-500 budget entries

-- Count total budget allocations
SELECT COUNT(*) as total_budget_allocations FROM budget_allocations;

-- Count by budget category
SELECT budget_category, COUNT(*) as count
FROM budget_allocations
GROUP BY budget_category
ORDER BY count DESC;

-- Count by status
SELECT status, COUNT(*) as count
FROM budget_allocations
GROUP BY status
ORDER BY count DESC;

-- Sample data
SELECT id, fiscal_year, budget_category, allocated_amount, spent_amount, status
FROM budget_allocations
ORDER BY fiscal_year DESC, allocated_amount DESC
LIMIT 10;

-- Budget summary by fiscal year
SELECT
    fiscal_year,
    budget_category,
    SUM(allocated_amount) as total_allocated,
    SUM(spent_amount) as total_spent,
    ROUND((SUM(spent_amount)::numeric / NULLIF(SUM(allocated_amount), 0) * 100), 2) as utilization_percentage
FROM budget_allocations
GROUP BY fiscal_year, budget_category
ORDER BY fiscal_year DESC, total_allocated DESC;

-- Current year budget status
SELECT
    budget_category,
    SUM(allocated_amount) as allocated,
    SUM(spent_amount) as spent,
    SUM(allocated_amount) - SUM(spent_amount) as remaining
FROM budget_allocations
WHERE fiscal_year = EXTRACT(YEAR FROM CURRENT_DATE)
GROUP BY budget_category
ORDER BY allocated DESC;

-- Budget by region
SELECT
    region,
    COUNT(*) as allocations,
    SUM(allocated_amount) as total_allocated,
    SUM(spent_amount) as total_spent
FROM budget_allocations
GROUP BY region
ORDER BY total_allocated DESC;

--------------------------------------------------------------------------------
SEEDER 37: AUDIT TRAILS
--------------------------------------------------------------------------------
File: 37-seed-audit-trails.ts
Table: audit_trails
Expected: 1000-5000 audit entries

-- Count total audit trails
SELECT COUNT(*) as total_audit_trails FROM audit_trails;

-- Count by action
SELECT action, COUNT(*) as count
FROM audit_trails
GROUP BY action
ORDER BY count DESC;

-- Count by entity type
SELECT entity_type, COUNT(*) as count
FROM audit_trails
GROUP BY entity_type
ORDER BY count DESC;

-- Sample data
SELECT id, entity_type, entity_id, action, performed_by, performed_at
FROM audit_trails
ORDER BY performed_at DESC
LIMIT 10;

-- Recent audit activity (last 24 hours)
SELECT
    u.username,
    at.entity_type,
    at.action,
    at.performed_at
FROM audit_trails at
JOIN users u ON at.performed_by = u.id
WHERE at.performed_at >= NOW() - INTERVAL '24 hours'
ORDER BY at.performed_at DESC
LIMIT 20;

-- Audit activity by user
SELECT
    u.username,
    u.role,
    COUNT(at.id) as total_actions,
    COUNT(DISTINCT at.entity_type) as entity_types_modified
FROM audit_trails at
JOIN users u ON at.performed_by = u.id
GROUP BY u.username, u.role
ORDER BY total_actions DESC
LIMIT 10;

-- Critical actions (DELETE, UPDATE on sensitive tables)
SELECT
    u.username,
    at.entity_type,
    at.action,
    at.performed_at
FROM audit_trails at
JOIN users u ON at.performed_by = u.id
WHERE at.action IN ('DELETE', 'UPDATE')
  AND at.entity_type IN ('users', 'payments', 'escrow_transactions')
ORDER BY at.performed_at DESC
LIMIT 20;

--------------------------------------------------------------------------------
SEEDER 38: SCHOOL STUDENT COUNTS
--------------------------------------------------------------------------------
File: 38-seed-school-student-counts.ts
Table: school_student_counts
Expected: 500-2000 count records

-- Count total student count records
SELECT COUNT(*) as total_student_counts FROM school_student_counts;

-- Sample data
SELECT id, school_id, academic_year, total_students, recorded_date
FROM school_student_counts
ORDER BY recorded_date DESC
LIMIT 10;

-- Latest student counts by school
SELECT
    s.name as school_name,
    ssc.academic_year,
    ssc.total_students,
    ssc.recorded_date
FROM school_student_counts ssc
JOIN schools s ON ssc.school_id = s.id
WHERE (ssc.school_id, ssc.recorded_date) IN (
    SELECT school_id, MAX(recorded_date)
    FROM school_student_counts
    GROUP BY school_id
)
ORDER BY ssc.total_students DESC
LIMIT 10;

-- Student count trends
SELECT
    academic_year,
    SUM(total_students) as total_students,
    AVG(total_students) as avg_per_school,
    COUNT(DISTINCT school_id) as schools_reporting
FROM school_student_counts
GROUP BY academic_year
ORDER BY academic_year DESC;

-- Schools with growing enrollment
SELECT
    s.name as school_name,
    ssc1.academic_year as prev_year,
    ssc1.total_students as prev_students,
    ssc2.academic_year as current_year,
    ssc2.total_students as current_students,
    ssc2.total_students - ssc1.total_students as growth
FROM school_student_counts ssc1
JOIN school_student_counts ssc2 ON ssc1.school_id = ssc2.school_id
JOIN schools s ON ssc1.school_id = s.id
WHERE ssc2.academic_year = ssc1.academic_year + 1
  AND ssc2.total_students > ssc1.total_students
ORDER BY growth DESC
LIMIT 10;

--------------------------------------------------------------------------------
SEEDER 39: CATERING MENU CATALOG
--------------------------------------------------------------------------------
File: 39-seed-catering-menu-catalog.ts
Table: catering_menu_catalog
Expected: 100-300 menu items

-- Count total menu catalog items
SELECT COUNT(*) as total_menu_catalog_items FROM catering_menu_catalog;

-- Count by category
SELECT category, COUNT(*) as count
FROM catering_menu_catalog
GROUP BY category
ORDER BY count DESC;

-- Sample data
SELECT id, catering_id, menu_code, menu_name, category, base_price, is_available
FROM catering_menu_catalog
ORDER BY catering_id, category
LIMIT 10;

-- Available vs unavailable items
SELECT
    is_available,
    COUNT(*) as count
FROM catering_menu_catalog
GROUP BY is_available;

-- Menu items by catering
SELECT
    c.name as catering_name,
    COUNT(cmc.id) as total_items,
    SUM(CASE WHEN cmc.is_available THEN 1 ELSE 0 END) as available_items,
    AVG(cmc.base_price) as avg_price
FROM catering_menu_catalog cmc
JOIN caterings c ON cmc.catering_id = c.id
GROUP BY c.name
ORDER BY total_items DESC;

-- Nutritional summary by category
SELECT
    category,
    COUNT(*) as items,
    AVG(calories) as avg_calories,
    AVG(protein_grams) as avg_protein,
    AVG(base_price) as avg_price
FROM catering_menu_catalog
GROUP BY category
ORDER BY category;

-- Vegetarian options
SELECT
    c.name as catering_name,
    cmc.menu_name,
    cmc.category,
    cmc.base_price
FROM catering_menu_catalog cmc
JOIN caterings c ON cmc.catering_id = c.id
WHERE cmc.is_vegetarian = true
ORDER BY c.name, cmc.category;

--------------------------------------------------------------------------------
SEEDER 40: DELIVERY ROUTES
--------------------------------------------------------------------------------
File: 40-seed-delivery-routes.ts
Table: delivery_routes
Expected: 50-150 delivery routes

-- Count total delivery routes
SELECT COUNT(*) as total_delivery_routes FROM delivery_routes;

-- Count by status
SELECT route_status, COUNT(*) as count
FROM delivery_routes
GROUP BY route_status
ORDER BY count DESC;

-- Sample data
SELECT id, catering_id, route_name, route_date, driver_name, vehicle_number, route_status
FROM delivery_routes
ORDER BY route_date DESC
LIMIT 10;

-- Routes by catering
SELECT
    c.name as catering_name,
    COUNT(dr.id) as total_routes,
    SUM(dr.total_schools) as total_schools_served,
    SUM(dr.total_portions) as total_portions_delivered
FROM delivery_routes dr
JOIN caterings c ON dr.catering_id = c.id
GROUP BY c.name
ORDER BY total_routes DESC;

-- Route efficiency metrics
SELECT
    route_status,
    COUNT(*) as routes,
    AVG(total_distance_km) as avg_distance,
    AVG(total_schools) as avg_schools_per_route,
    AVG(optimization_score) as avg_optimization_score
FROM delivery_routes
GROUP BY route_status
ORDER BY route_status;

-- Active routes today
SELECT
    c.name as catering_name,
    dr.route_name,
    dr.driver_name,
    dr.vehicle_number,
    dr.total_schools,
    dr.total_portions,
    dr.estimated_start_time,
    dr.estimated_end_time
FROM delivery_routes dr
JOIN caterings c ON dr.catering_id = c.id
WHERE dr.route_date = CURRENT_DATE AND dr.route_status IN ('planned', 'in_progress')
ORDER BY dr.estimated_start_time;

-- Route performance (completed routes)
SELECT
    route_name,
    total_distance_km,
    total_schools,
    estimated_start_time,
    estimated_end_time,
    actual_start_time,
    actual_end_time,
    EXTRACT(EPOCH FROM (actual_end_time::time - estimated_end_time::time))/60 as delay_minutes
FROM delivery_routes
WHERE route_status = 'completed' AND actual_end_time IS NOT NULL
ORDER BY route_date DESC
LIMIT 10;


================================================================================
QUICK VERIFICATION SCRIPT
================================================================================

-- Run this to get overview of all seeding results
SELECT
    'users' as table_name, COUNT(*) as count FROM users
UNION ALL SELECT 'menu_items', COUNT(*) FROM menu_items
UNION ALL SELECT 'allocations', COUNT(*) FROM allocations
UNION ALL SELECT 'deliveries', COUNT(*) FROM deliveries
UNION ALL SELECT 'verifications', COUNT(*) FROM verifications
UNION ALL SELECT 'payments', COUNT(*) FROM payments
UNION ALL SELECT 'issues', COUNT(*) FROM issues
UNION ALL SELECT 'escrow_transactions', COUNT(*) FROM escrow_transactions
UNION ALL SELECT 'payment_events', COUNT(*) FROM payment_events
UNION ALL SELECT 'delivery_confirmations', COUNT(*) FROM delivery_confirmations
UNION ALL SELECT 'public_payment_feed', COUNT(*) FROM public_payment_feed
UNION ALL SELECT 'refunds', COUNT(*) FROM refunds
UNION ALL SELECT 'payment_methods', COUNT(*) FROM payment_methods
UNION ALL SELECT 'blockchain_sync_log', COUNT(*) FROM blockchain_sync_log
UNION ALL SELECT 'poverty_data_cache', COUNT(*) FROM poverty_data_cache
UNION ALL SELECT 'ai_food_analyses', COUNT(*) FROM ai_food_analyses
UNION ALL SELECT 'anomaly_alerts', COUNT(*) FROM anomaly_alerts
UNION ALL SELECT 'vendor_risk_assessments', COUNT(*) FROM vendor_risk_assessments
UNION ALL SELECT 'stunting_data_cache', COUNT(*) FROM stunting_data_cache
UNION ALL SELECT 'blockchain_transaction_history', COUNT(*) FROM blockchain_transaction_history
UNION ALL SELECT 'smart_contract_events_raw', COUNT(*) FROM smart_contract_events_raw
UNION ALL SELECT 'wallet_balances_snapshot', COUNT(*) FROM wallet_balances_snapshot
UNION ALL SELECT 'user_activity_logs', COUNT(*) FROM user_activity_logs
UNION ALL SELECT 'notification_history', COUNT(*) FROM notification_history
UNION ALL SELECT 'system_config', COUNT(*) FROM system_config
UNION ALL SELECT 'weekly_menu_plans', COUNT(*) FROM weekly_menu_plans
UNION ALL SELECT 'performance_metrics', COUNT(*) FROM performance_metrics
UNION ALL SELECT 'regional_statistics', COUNT(*) FROM regional_statistics
UNION ALL SELECT 'catering_contracts', COUNT(*) FROM catering_contracts
UNION ALL SELECT 'photo_evidence', COUNT(*) FROM photo_evidence
UNION ALL SELECT 'public_feedback', COUNT(*) FROM public_feedback
UNION ALL SELECT 'budget_allocations', COUNT(*) FROM budget_allocations
UNION ALL SELECT 'audit_trails', COUNT(*) FROM audit_trails
UNION ALL SELECT 'school_student_counts', COUNT(*) FROM school_student_counts
UNION ALL SELECT 'catering_menu_catalog', COUNT(*) FROM catering_menu_catalog
UNION ALL SELECT 'delivery_routes', COUNT(*) FROM delivery_routes
ORDER BY table_name;
